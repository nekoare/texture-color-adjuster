// LAB Statistics Computation Compute Shader
// Calculates mean and standard deviation for LAB channels

#pragma kernel ComputeMean
#pragma kernel ComputeStdDev

Texture2D<float4> InputTexture;
RWStructuredBuffer<uint> MeanBuffer; // (lSum, aSum, bSum, count) as uint bits
RWStructuredBuffer<uint> StdDevBuffer; // (lVariance, aVariance, bVariance, unused) as uint bits

float4 MeanValues; // Pre-calculated means for StdDev kernel
float AlphaThreshold;

groupshared float4 sharedData[64]; // For reduction

// Color space conversion (same as main shader)
float3 RGBtoXYZ(float3 rgb)
{
    float r = rgb.r <= 0.04045 ? rgb.r / 12.92 : pow(max((rgb.r + 0.055) / 1.055, 0.0), 2.4);
    float g = rgb.g <= 0.04045 ? rgb.g / 12.92 : pow(max((rgb.g + 0.055) / 1.055, 0.0), 2.4);
    float b = rgb.b <= 0.04045 ? rgb.b / 12.92 : pow(max((rgb.b + 0.055) / 1.055, 0.0), 2.4);

    float x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375;
    float y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750;
    float z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041;

    return float3(x, y, z);
}

float3 XYZtoLAB(float3 xyz)
{
    const float3 whitePoint = float3(0.95047, 1.00000, 1.08883);
    float3 normalized = xyz / whitePoint;

    float epsilon = 0.008856;
    float kappa = 903.3;

    float fx = normalized.x > epsilon ? pow(max(normalized.x, 0.0), 1.0 / 3.0) : (kappa * normalized.x + 16.0) / 116.0;
    float fy = normalized.y > epsilon ? pow(max(normalized.y, 0.0), 1.0 / 3.0) : (kappa * normalized.y + 16.0) / 116.0;
    float fz = normalized.z > epsilon ? pow(max(normalized.z, 0.0), 1.0 / 3.0) : (kappa * normalized.z + 16.0) / 116.0;

    float L = 116.0 * fy - 16.0;
    float A = 500.0 * (fx - fy);
    float B = 200.0 * (fy - fz);

    return float3(L, A, B);
}

float3 RGBtoLAB(float3 rgb)
{
    return XYZtoLAB(RGBtoXYZ(rgb));
}

[numthreads(8,8,1)]
void ComputeMean(uint3 id : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex)
{
    uint width, height;
    InputTexture.GetDimensions(width, height);

    float4 localSum = float4(0, 0, 0, 0);

    if (id.x < width && id.y < height)
    {
        float4 pixel = InputTexture[id.xy];

        // Only process opaque pixels
        if (pixel.a >= AlphaThreshold)
        {
            float3 lab = RGBtoLAB(pixel.rgb);
            localSum = float4(lab.x, lab.y, lab.z, 1.0);
        }
    }

    // Store in shared memory
    sharedData[groupIndex] = localSum;
    GroupMemoryBarrierWithGroupSync();

    // Parallel reduction
    for (uint s = 32; s > 0; s >>= 1)
    {
        if (groupIndex < s)
        {
            sharedData[groupIndex] += sharedData[groupIndex + s];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Write result (atomic float addition workaround)
    if (groupIndex == 0)
    {
        // Convert float to uint bits for atomic operations
        uint newValueX, newValueY, newValueZ, newValueW;
        uint compareX, compareY, compareZ, compareW;
        uint originalX, originalY, originalZ, originalW;

        // Atomic add for X component (L sum)
        do {
            compareX = MeanBuffer[0];
            originalX = compareX;
            newValueX = asuint(asfloat(compareX) + sharedData[0].x);
            InterlockedCompareExchange(MeanBuffer[0], compareX, newValueX, originalX);
        } while (originalX != compareX);

        // Atomic add for Y component (a sum)
        do {
            compareY = MeanBuffer[1];
            originalY = compareY;
            newValueY = asuint(asfloat(compareY) + sharedData[0].y);
            InterlockedCompareExchange(MeanBuffer[1], compareY, newValueY, originalY);
        } while (originalY != compareY);

        // Atomic add for Z component (b sum)
        do {
            compareZ = MeanBuffer[2];
            originalZ = compareZ;
            newValueZ = asuint(asfloat(compareZ) + sharedData[0].z);
            InterlockedCompareExchange(MeanBuffer[2], compareZ, newValueZ, originalZ);
        } while (originalZ != compareZ);

        // Atomic add for W component (count)
        do {
            compareW = MeanBuffer[3];
            originalW = compareW;
            newValueW = asuint(asfloat(compareW) + sharedData[0].w);
            InterlockedCompareExchange(MeanBuffer[3], compareW, newValueW, originalW);
        } while (originalW != compareW);
    }
}

[numthreads(8,8,1)]
void ComputeStdDev(uint3 id : SV_DispatchThreadID, uint3 groupThreadID : SV_GroupThreadID, uint groupIndex : SV_GroupIndex)
{
    uint width, height;
    InputTexture.GetDimensions(width, height);

    float4 localVariance = float4(0, 0, 0, 0);

    if (id.x < width && id.y < height)
    {
        float4 pixel = InputTexture[id.xy];

        // Only process opaque pixels
        if (pixel.a >= AlphaThreshold)
        {
            float3 lab = RGBtoLAB(pixel.rgb);

            float lDiff = lab.x - MeanValues.x;
            float aDiff = lab.y - MeanValues.y;
            float bDiff = lab.z - MeanValues.z;

            localVariance = float4(lDiff * lDiff, aDiff * aDiff, bDiff * bDiff, 0.0);
        }
    }

    // Store in shared memory
    sharedData[groupIndex] = localVariance;
    GroupMemoryBarrierWithGroupSync();

    // Parallel reduction
    for (uint s = 32; s > 0; s >>= 1)
    {
        if (groupIndex < s)
        {
            sharedData[groupIndex] += sharedData[groupIndex + s];
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // Write result (atomic float addition workaround)
    if (groupIndex == 0)
    {
        // Convert float to uint bits for atomic operations
        uint newValueX, newValueY, newValueZ;
        uint compareX, compareY, compareZ;
        uint originalX, originalY, originalZ;

        // Atomic add for X component (L variance)
        do {
            compareX = StdDevBuffer[0];
            originalX = compareX;
            newValueX = asuint(asfloat(compareX) + sharedData[0].x);
            InterlockedCompareExchange(StdDevBuffer[0], compareX, newValueX, originalX);
        } while (originalX != compareX);

        // Atomic add for Y component (a variance)
        do {
            compareY = StdDevBuffer[1];
            originalY = compareY;
            newValueY = asuint(asfloat(compareY) + sharedData[0].y);
            InterlockedCompareExchange(StdDevBuffer[1], compareY, newValueY, originalY);
        } while (originalY != compareY);

        // Atomic add for Z component (b variance)
        do {
            compareZ = StdDevBuffer[2];
            originalZ = compareZ;
            newValueZ = asuint(asfloat(compareZ) + sharedData[0].z);
            InterlockedCompareExchange(StdDevBuffer[2], compareZ, newValueZ, originalZ);
        } while (originalZ != compareZ);
    }
}
